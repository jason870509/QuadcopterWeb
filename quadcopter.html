 <!DOCTYPE html>
<html>
  <head>
      <title>Quadcopter</title>
      <meta charset="utf-8">
      <style>
          #info{
            position:absolute;
            top:2%;
            width:100%;
            font-family:"Times New Roman";
            color:black;
            text-align:center;
          }
          #text{
            position:absolute;
            bottom:2%;
            width:100%;
            color: #ffffff;
            font-family:"Times New Roman";
            text-align:center;
          }
          #yreftext {
            width:2%
          }
          body {
            overflow:hidden;
          }
      </style>
  </head>
  <body>
    <div id="info">
      <p> Up/Down to Change Hover Altitude; Left/Right to Yaw; A/D to Roll; W/S to Pitch </p>
      <div id="Cameras" style="position:absolute;left:10px;background:white; width:28vw; height:35vh; float:left;">
        <canvas id="mycanvas"></canvas>
      </div>
      <button id="thrustUp">T-Up</button>
      <button id="thrustDo">T-Down</button>
      <button id="cwTurn">y-Left</button>
      <button id="ccwTurn">y-Right</button>
      <button id="rollRight">r-PORT</button>
      <button id="rollLeft">r-STARBOARD</button>
      <button id="pitchFore">p-FORE</button>
      <button id="pitchAft">p-AFT</button>
      <button id="stop">Space-Stop</button><br>
      <input id="yreftext" type="text" value=2><br>
      <!-- <input id="yawtext" type="text" value=0>
      <input type=range min=-1 max=1 step="0.05" value = 0 id='yawref'><br>
      <button id="flyup">Take-off</button> -->
      <button id="takeoff"font-family:"Times New Roman">Take-off</button>
      <button id="land"font-family:"Times New Roman">Land</button><br>
      <button id="CircleMovement"font-family:"Times New Roman">Circle-Movement</button>
      <input type=range min=-3.14 max=3.14 step="0.05" value = 0 font-family:"Times New Roman" id='curveAngle'><br>
      <button id="s-line"font-family:"Times New Roman">S-line</button>
      <input type=range min=-3.14 max=3.14 step="0.05" value = 0 id='SlineAngle'font-family:"Times New Roman"><br>
      <button id="8-loop"font-family:"Times New Roman">8-Loop</button>
      <input type=range min=-3.14 max=3.14 step="0.05" value = 0 id='8loopAngle'font-family:"Times New Roman"><br>
      <button id="direction"font-family:"Times New Roman">ShowDirection</button>
      <button id="plane"font-family:"Times New Roman">ShowPlane</button><br>
      <input type=range min=-5 max=-0.5 step="0.05" value = -2 id='CameraFar' font-family:"Times New Roman"> ChangeCamera<br>
    </div>  
    <div id="text"></div>
    <script src="build/three.min.js"></script>
    <script src="build/OrbitControls.js"></script>
    <script src="build/cannon.js"></script>

    <script src="tools/KeyboardState.js"></script>
    <script src="tools/Gyroscope.js"></script>
    <script src="tools/test2D.js"></script>
    <script src="tools/Linesegmentsgeometry.js"></script>
    <script src="tools/Linegeometry.js"></script>
    <script src="tools/Linematerial.js"></script>
    <script src="tools/Linesegments2.js"></script>
    <script src="tools/Line2.js"></script>
    <script src="tools/createFatLine.js"></script>
    <script src="tools/HudButton.js"></script>
    <script src="tools/jquery-2.1.4.min.js"></script>

    <script src="drone/qcommon.js"></script>
    <script src="drone/qangles.js"></script>
    <script src="drone/qservo.js"></script>
    <script>
      $('#curveAngle').change ( function() {
          angleRef1 = $(this).val();
      });
      $('#8loopAngle').change ( function() {
          angleRef2 = $(this).val();
      });
      $('#SlineAngle').change ( function() {
          angleRef3 = $(this).val();
      });
      $('#CameraFar').change ( function() {
          camera_far = $(this).val();
      });

      $('#takeoff').click(function() {
          takeoff = !takeoff;
      });
      $('#land').click(function() {
          land=!land;
      });

      $('#CircleMovement').click(function() {
          quadcopter.curve_first = true;
          quadcopter.curve_type = 0;
      });
      $('#s-line').click(function() {
          quadcopter.curve_first = true;
          quadcopter.curve_type = 1;
      });
      $('#8-loop').click(function() {
          quadcopter.curve_first = true;
          quadcopter.curve_type = 2;
      });
            
      $('#direction').click(function() {
          quadcopter.showTargetPoint = !quadcopter.showTargetPoint;
      });
      $('#plane').click(function() {
          quadcopter.showPlane = !quadcopter.showPlane;
      });

      var isVisible = true; // motor name
      var world, body, quadcopter; 
      var scene, camera, renderer, keyboard;
      var upCamera, upCamera_renderer, camera_far = -2;
      var clock = new THREE.Clock();
      var sceneHUD, cameraHUD;
      var HUD_object = {
        sprite: [],
        pointer: [],
        controlRange: [],
      }

      // HUD 陀螺儀
      var handUp = 0, controlOne = 0, mousepick = false;
      var ControlPick;

      var pickables = [];
      var mouse = new THREE.Vector2();
      var raycaster = new THREE.Raycaster();
      
      // flight maneuver
      // hovering
      var yref = 0; 
      var fly_toggle = false;
      var takeoff = false, land = false;

      // Roll, Yaw, Pitch
      var turning = true, rolling = true, pitching=true;
      var rYaw = 0, rRoll = 0, rPitch = 0;
      var yawAngle = 0, yawRef = 0;
      var rollAngle = 0, rollRef = 0;
      var pitchAngle = 0, pitchRef = 0;
      var nowPitch = false, nowHover = false, nowRoll = false, nowYaw = false;

      // HUD 的 PD 控制系統參數
      var y1, v1, speedRef = [], y2, v2, numberRef1, y3, v3, numberRef2, y4, v4, numberRef3, y5, v5, numberRef4;
      var angleY = [0, 0, 0], anglev1, angleRef1, anglev2, angleRef2, anglev3, angleRef3;


      var dtt;
      var omega, omega0, omega1, omega2, omega3;
      var omegaGain = 1.0, omegaHover;
      const SIZE = 1;
      const PROP_KK = 0.1;
      

      var cylindery1, cylindery2, cylindery3, cylindery4, SpeedChange = 2; 
      var showdetail = false;
      var circles = [];


      init();
      animate();

      function init() {
        // =================================== Init ===================================
        keyboard = new KeyboardState();
        
        initThree();
        initCannon();
        createDashboard(HUD_object["sprite"], HUD_object["pointer"], HUD_object["controlRange"]);
        
        var gyro = new THREE.Gyroscope();
        scene.add (gyro)
        gyro.add (camera);
        quadcopter.body.add (gyro);
        
        // =================================== HUD ===================================
        var upCamera_width = $('#Cameras').innerWidth();
        var upCamera_height = $('#Cameras').innerHeight();
        var upCamera_canvas = document.getElementById('mycanvas');
        upCamera_renderer = new THREE.WebGLRenderer({
          canvas: upCamera_canvas
        });
        upCamera_renderer.setSize(upCamera_width, upCamera_height);
        upCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

        // Camera
        cameraHUD = new THREE.OrthographicCamera(-20, 20, 10, -10, -10, 1000);


        // =================================== 陀螺儀設定 ===================================
        var _winDevice = !!navigator.platform.match(/Win32|Win16/);
        console.log(_winDevice + ' ' + navigator.platform);
        if(_winDevice){
            document.addEventListener('mousedown', hudButtonPick, false);
            document.addEventListener('mouseup', hudButtonUp, false);
            document.addEventListener('mousemove', hudButtonMove, false);
        }
        else {
            document.addEventListener('touchstart', hudButtonPickMobile, false);
            document.addEventListener('touchend', hudButtonUpMobile, false);
            document.addEventListener('touchmove', hudButtonMoveMobile, false);
        }

        // omegaHover: stable hover speed
        omegaHover = Math.sqrt ( body.mass * world.gravity.length()/4/PROP_KK );
        pickables.push( quadcopter.body.children[5],
                        quadcopter.body.children[6],
                        quadcopter.body.children[7],
                        quadcopter.body.children[8] );  
        console.log(pickables);
        targetPos = new THREE.Vector3(5, 5,-5);
        quadcopter.target_position = new THREE.Vector3(5, 5,-5);

        quadcopter.target_point = new THREE.Mesh( new THREE.CylinderGeometry(0.05,0.05, 0.1, 20), 
                                       new THREE.MeshPhongMaterial({ visible: true }));
        scene.add(quadcopter.target_point);
        

        sy = [];
        sy[1]=v1=y2=v2=numberRef1=speedRef[1]=sy[2]=sv2=speedRef[2]=sy[3]=sv3=speedRef[3]=sy[4]=sv4=speedRef[4]=y3=v3=numberRef2=y4=v4=numberRef3=y5=v5=numberRef4=0;
        cylindery1=cylinderv1=cylinderRef1=cylindery2=cylinderv2=cylinderRef2=cylindery3=cylinderv3=cylinderRef3=cylindery4=cylinderv=cylinderRef4=0;
        anglev1=angleRef1=anglev2=angleRef2=anglev3=angleRef3=0;
        // document.addEventListener('mousedown', onDocumentMouseDown, false)

        // =================================== Fat Line ===================================
        quadcopter.fatline[0] = new FatLine(0);
        quadcopter.fatline[1] = new FatLine(1);
      }

      function onWindowResize() {
          // renderer resize
          renderer.setSize(window.innerWidth, window.innerHeight);
          whRatio = window.innerWidth / window.innerHeight;

          // perspective camera resize
          camera1.aspect = whRatio;
          camera1.updateProjectionMatrix();
          
          // orthographic camera resize
          halfH = 20;
          halfW = whRatio * halfH;
          cameraHUD.left = -halfW;
          cameraHUD.right = halfW;
          cameraHUD.top = halfH;
          cameraHUD.bottom = -halfH;
          cameraHUD.updateProjectionMatrix();

          dashBoard[0].position.set(-halfW / 2.5, -(halfH - halfW / 10), 0)
          dashBoard[1].position.set(-halfW / 8, -(halfH - halfW / 10), 0)
          dashBoard[2].position.set(halfW / 8, -(halfH - halfW / 10), 0)
          dashBoard[3].position.set(halfW / 2.5, -(halfH - halfW / 10), 0)
      }


      function onDocumentMouseDown(event) {
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          
          // find intersections
          raycaster.setFromCamera(mouse, camera);
          var intersects = raycaster.intersectObjects( pickables );
          if(intersects.length > 0){
            showdetail = !showdetail;
            console.log("2");
          }
      }


      function animate() {
          var dt = clock.getDelta();
          // console.log(dt)
          upCamera.position.copy(quadcopter.body.localToWorld(new THREE.Vector3(1, 1, camera_far)));
          upCamera.lookAt(quadcopter.body.position);
          upCamera_renderer.render(scene, upCamera);
        
          // 起飛
          if(takeoff) {
            if(!fly_toggle){
              yref = 5;
              fly_toggle = true;
              takeoff = false;
            }
          }
          
          // 降落
          if(land) {
            if(fly_toggle){
              yref = 0;
              fly_toggle = false;
              land = false;
            }
          }

          var f1 = speedServo(sy[1], v1, speedRef[1]); 
          dtt = 0.005;
          v1 += f1*dtt;
          sy[1] += v1*dtt;

          var f2 = numberServo(y2,v2,numberRef1); 
          v2 += f2*dtt;
          y2 += v2*dtt;
          cylindery1 =y2*0.05;
        
          var f3 = numberServo(y3,v3,numberRef2); 
          v3 += f3*dtt;
          y3 += v3*dtt;
          cylindery2 =y3*0.05;

          var f4 = numberServo(y4,v4,numberRef3); 
          v4 += f4*dtt;
          y4 += v4*dtt;
          cylindery3 =y4*0.05;

          var f5 = numberServo(y5,v5,numberRef4); 
          v5 += f5*dtt;
          y5 += v5*dtt;
          cylindery4 =y5*0.05;
          
          var f6= speedServo(sy[2],sv2,speedRef[2]); 
          sv2 += f6*dtt;
          sy[2] += sv2*dtt;
          
          var f7 = speedServo(sy[3],sv3,speedRef[3]); 
          sv3 += f7*dtt;
          sy[3] += sv3*dtt;
          
          var f8 = speedServo(sy[4],sv4,speedRef[4]); 
          sv4 += f8*dtt;
          sy[4]+= sv4*dtt;
        
          var f9 = speedServo(angleY[0],anglev1,angleRef1); 
          anglev1 += f9*dtt;
          angleY[0] += anglev1*dtt;

          var f10 = speedServo(angleY[1],anglev2,angleRef2); 
          anglev2 += f10*dtt;
          angleY[1] += anglev2*dtt;

          var f11 = speedServo(angleY[2],anglev3,angleRef3); 
          anglev3 += f11*dtt;
          angleY[2] += anglev3*dtt;

          
          quadcopter.follow_line();
          
          
        /*if(controller&&yref==0)
        {
          yref=2;
              var turning = false;
          var rolling = false;
          var pitching= false;
        }
        if(controller)
        {
              var turning = false;
          var rolling = false;
          var pitching= false;
        }
        if(!controller&&yref>0.5)
        {
          yref=0.5;
        }
        if(!controller&&yref==0.5)
        {
          //omega0=omega1=omega2=omega3=0;
          var turning = true;
          var rolling = true;
          var pitching= true;
        }*/
        // not in thrust+/- mode, activate hoverServo
        if (omegaGain === 1.0) 
        omega = hoverServo(body, dt);
        else
        omega = omegaGain*omegaHover;  // this looks much better
        omega = Math.clamp (omega, 0, 50);
      // console.log("ryaw: "+rYaw+" "+turning);
        
        if (! turning) {
          //console.log("turningryaw: "+rYaw);
          rYaw = yawServo (body, dt);
          //console.log("servoryaw: "+rYaw);
          rYaw = Math.clamp (rYaw, -omega, omega);
        }  
      // always activate rollServo and pitchServo
        rRoll = rollServo (body, dt);
        rRoll = Math.clamp (rRoll, -omega*0.15, omega*0.15);
        rPitch = pitchServo (body, dt);
        rPitch = Math.clamp (rPitch, -omega*0.15, omega*0.15);
        
        var omega0Temp = omega0;
        var omega1Temp = omega1;
        var omega2Temp = omega2;
        var omega3Temp = omega3;
        omega0 = omega - rYaw - rRoll - rPitch;
        omega1 = omega + rYaw - rRoll + rPitch;
        omega2 = omega - rYaw + rRoll + rPitch;
        omega3 = omega + rYaw + rRoll - rPitch;//0x1742ab
        if(showdetail){
      
        cylinderRef1=omega0*8;
        cylinderRef2=omega1*8;
        cylinderRef3=omega2*8;
        cylinderRef4=omega3*8;
        // quadcopter.body.children[13].children[0].visible=true;
        // quadcopter.body.children[14].children[0].visible=true;
        // quadcopter.body.children[15].children[0].visible=true;
        // quadcopter.body.children[16].children[0].visible=true;
        // quadcopter.body.children[25].children[0].visible=true;
        // quadcopter.body.children[26].children[0].visible=true;
        // quadcopter.body.children[27].children[0].visible=true;
        // quadcopter.body.children[28].children[0].visible=true;
      
        quadcopter.body.children[25].children[0].scale.y = -5*cylindery1;
        quadcopter.body.children[26].children[0].scale.y = 5*cylindery2;
        quadcopter.body.children[27].children[0].scale.y = -5*cylindery3;
        quadcopter.body.children[28].children[0].scale.y = 5*cylindery4;
      /* quadcopter.body.children[13].add(new THREE.AxesHelper (0.5));
      quadcopter.body.children[14].add(new THREE.AxesHelper (0.5));
      quadcopter.body.children[15].add(new THREE.AxesHelper (0.5));
      quadcopter.body.children[16].add(new THREE.AxesHelper (0.5));*/
      }
      else {
        // quadcopter.body.children[13].children[0].visible=false;
        // quadcopter.body.children[14].children[0].visible=false;
        // quadcopter.body.children[15].children[0].visible=false;
        // quadcopter.body.children[16].children[0].visible=false;
        // quadcopter.body.children[25].children[0].visible=false;
        // quadcopter.body.children[26].children[0].visible=false;
        // quadcopter.body.children[27].children[0].visible=false;
        // quadcopter.body.children[28].children[0].visible=false;
      /*  quadcopter.body.children[13].remove(new THREE.AxesHelper (0.5));
      quadcopter.body.children[14].remove(new THREE.AxesHelper (0.5));
      quadcopter.body.children[15].remove(new THREE.AxesHelper (0.5));
      quadcopter.body.children[16].remove(new THREE.AxesHelper (0.5));*/
      }
        /*omega0 = omega  - rRoll - rPitch;
        omega1 = omega  - rRoll + rPitch;
        omega2 = omega  + rRoll + rPitch;
        omega3 = omega  + rRoll - rPitch;*/
        /*omega0 = omega - rYaw;
        omega1 = omega + rYaw;
        omega2 = omega - rYaw;
        omega3 = omega + rYaw;*/
        body.torque = new CANNON.Vec3(0,0,0);
        body.angularDamping = 0.39
        body.linearDamping = 0.39
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega0*omega0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega1*omega1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega2*omega2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega3*omega3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 
          
        let KT = 0.1;
        // need to add the last argument
        body.torque.vadd (new CANNON.Vec3(0, -KT*omega0*omega0,0), body.torque);
        body.torque.vadd (new CANNON.Vec3(0,  KT*omega1*omega1,0), body.torque);
        body.torque.vadd (new CANNON.Vec3(0, -KT*omega2*omega2,0), body.torque);
        body.torque.vadd (new CANNON.Vec3(0,  KT*omega3*omega3,0), body.torque);
        //bug ... for pitching, weird number from KT not zero
        //console.log (body.torque)         
        //console.log("omega0:"+omega0.toFixed(2)+" omega1:"+omega1.toFixed(2)+" omega2:"+omega2.toFixed(2)+" omega3:"+omega3.toFixed(2));
        //requestAnimationFrame( animate );
        //renderer.render( scene, camera );
          var angle = [], t = 10;
          for(i=0;i<4;i++){
          angle[i] = 0
          }
          angle[0] = 4.9 / 14 * omega0;
          numberRef1=-omega0.toFixed(1);
          HUD_object["sprite"][0].text = y2.toFixed(2);
          angle[1] = 4.9 / 14 * omega1;
          numberRef2=omega1.toFixed(1);
          HUD_object["sprite"][1].text =y3.toFixed(2);
          numberRef3=-omega2.toFixed(1);
          angle[2] = 4.9 / 14 * omega2;
          HUD_object["sprite"][2].text = y4.toFixed(2);
          numberRef4=omega3.toFixed(1);;
          angle[3] = 4.9 / 14 * omega3;
          HUD_object["sprite"][3].text = y5.toFixed(2);
          for (i = 0; i < 4; i++) {
          angle[i] = Math.clamp(angle[i], 0, 4.9);
          speedRef[i+1]= -angle[i] + 0.86
          HUD_object["pointer"][i].rotation.z = sy[i+1];
          }
          render();
          handleKeys();
          HUDControler();
        updatePhysics();
        // render propeller in quadcopter.body
      // console.log(quadcopter.body.children[25].children[0].mesh.parameters)
        quadcopter.body.children[25].rotation.z += 2.5*omega0*dt;//motor1
        quadcopter.body.children[26].rotation.z -= 2.5*omega1*dt;//motor2
        quadcopter.body.children[27].rotation.z += 2.5*omega2*dt;//motor3
        quadcopter.body.children[28].rotation.z -= 2.5*omega3*dt;//motor4
      }
      function render(){
        camera.lookAt(quadcopter.body.position);
        renderer.clear(true);
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        renderer.render(sceneHUD, cameraHUD);
      }
      function handleKeys () {
        keyboard.update();
        // console.log("keyborad:",keyboard.down)
        const RATIO = 1.0003;
        /////////////////////////////////////////////////////////////
        // for hovering
        if (keyboard.pressed('up')) {
          // controller=true;
          $('#thrustUp').css ("background-color",  'red');
          omegaGain *= RATIO;
        }
        if (keyboard.up('up')) {
          yref = body.position.y;
          console.log ('set yref: ' + yref);
          omegaGain = 1;
          $('#thrustUp').css ("background-color",  'white');
        }
        if (keyboard.pressed('down')) {
          $('#thrustDo').css ("background-color",  'yellow');
          omegaGain /= RATIO;
        }
        if (keyboard.up('down')) {
          yref = body.position.y;
          console.log ('set yref: ' + yref);
          $('#thrustDo').css ("background-color",  'white');
          omegaGain = 1;
        }
        /////////////////////////////////////////////////////////////
        // for rolling
        if (keyboard.pressed('D')) {
          $('#rollRight').css ("background-color",  'yellow');
              //rRoll = omegaHover*0.01;
              //rolling = true;
          rollRef = 0.1;
        }
        if (keyboard.up('D')) {
          $('#rollRight').css ("background-color",  'white');
          //rRoll = 0;//-omegaHover*0.005;
          rollRef = 0;
          rolling = false;  
        }
        if (keyboard.pressed('A')) {
          $('#rollLeft').css ("background-color",  'yellow');
              //rRoll = - omegaHover*0.01;
              //rolling = true;
              rollRef = -0.1;
        }
        if (keyboard.up('A')) {
          $('#rollLeft').css ("background-color",  'white');
          rollRef = 0;
          rolling = false;    
        }
        /////////////////////////////////////////////////////////////
        // for pitching
        if (keyboard.pressed('W')) {
          $('#pitchFore').css ("background-color",  'yellow');
              //rRoll = omegaHover*0.01;
              //rolling = true;
          pitchRef = 0.1;
          pitching=true;
        }
        if (keyboard.up('W')) {
          $('#pitchFore').css ("background-color",  'white');
          //rRoll = 0;//-omegaHover*0.005;
          pitchRef = 0;
          pitching = false; 
        }
        if (keyboard.pressed('S')) {
          $('#pitchAft').css ("background-color",  'yellow');
              //rRoll = - omegaHover*0.01;
              //rolling = true;
              pitchRef = -0.1;
              pitching=true;
        }
        if (keyboard.up('S')) {
          $('#pitchAft').css ("background-color",  'white');
          pitchRef = 0;
          pitching = false;   
        }
        /////////////////////////////////////////////////////////////
        // for yawing
          if (keyboard.pressed('left')) {
          $('#cwTurn').css ("background-color",  'yellow');
              rYaw = omegaHover*0.1;
              turning = true;
        }
        if (keyboard.up('left')) {
          $('#cwTurn').css ("background-color",  'white');
              rYaw = 0;
              turning = false;
          
            // set up stopping reference
            yawRef = getBodyYaw(body);
          if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
            console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
            //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
        }
        if (keyboard.pressed('right')) {
          $('#ccwTurn').css ("background-color",  'yellow');
              rYaw = -omegaHover*0.1;
              turning = true;
        }
        if (keyboard.up('right')) {
          $('#ccwTurn').css ("background-color",  'white');
          rYaw = 0;
          turning = false;
          // set up stopping reference
          yawRef = getBodyYaw(body);
          if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
              //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
            console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
            console.log(turning+omegaHover);
        }
        if (keyboard.pressed('space')) {
          yawRef = getBodyYaw(body);
          rYaw=0;
          turning=false;
          pitchRef = 0;
          pitching = false; 
          rollRef = 0;
          rolling = false;  
          $('#stop').css ("background-color",  'yellow');
        }
        if (keyboard.up('space')) {
          $('#stop').css ("background-color",  'white');
        }
          $('#gain').val (omegaGain);
        $('#yreftext').val (yref.toFixed(2));
      }
      function updatePhysics() {
        var timeStep=1/48;
        world.step(timeStep);
        // Copy coordinates from Cannon.js to Three.js
        quadcopter.body.position.copy(body.position);
        quadcopter.body.quaternion.copy(body.quaternion); 
        yawAngle = getBodyYaw(body);
      if((yawAngle/Math.PI*180).toFixed(2)==360)yawAngle=0;
        rollAngle = getBodyRoll(body);
        pitchAngle = getBodyPitch(body);
        
      /* $('#text').html (`${omegaGain.toFixed(3)}:[ ${body.position.x.toFixed(3)}, ${body.position.y.toFixed(2)}, 
          ${body.position.z.toFixed(3)} ] <br>      
        [${yawRef.toFixed(3)}] : [Y: ${yawAngle.toFixed(3)} ] [R: ${rollAngle.toFixed(3)} ] [P: ${pitchAngle.toFixed(3)} ]  
        <br>
          [omega0:${omega0.toFixed(3)}] : [omega1: ${omega1.toFixed(3)} ] [omega2: ${omega2.toFixed(3)} ] [omega3: ${omega3.toFixed(3)} ]         `);  */
      }

    </script>
  </body>
</html>