 <!DOCTYPE html>
<html>
  <head>
      <title>Quadcopter</title>
      <meta charset="utf-8">
      <style>
          #info{
            position:absolute;
            top:2%;
            width:100%;
            font-family:"Times New Roman";
            color:black;
            text-align:center;
          }
          #text{
            position:absolute;
            bottom:2%;
            width:100%;
            color: #ffffff;
            font-family:"Times New Roman";
            text-align:center;
          }
          #yreftext {
            width:2%
          }
          body {
            overflow:hidden;
          }
      </style>
  </head>
  <body>
    <div id="info">
      <p> Up/Down to Change Hover Altitude; Left/Right to Yaw; A/D to Roll; W/S to Pitch </p>
      <div id="Cameras" style="position:absolute;left:10px;background:white; width:28vw; height:35vh; float:left;">
        <canvas id="mycanvas"></canvas>
      </div>
      <button id="thrustUp">T-Up</button>
      <button id="thrustDo">T-Down</button>
      <button id="cwTurn">y-Left</button>
      <button id="ccwTurn">y-Right</button>
      <button id="rollRight">r-PORT</button>
      <button id="rollLeft">r-STARBOARD</button>
      <button id="pitchFore">p-FORE</button>
      <button id="pitchAft">p-AFT</button>
      <button id="stop">Space-Stop</button><br>
      <input id="yreftext" type="text" value=2><br>
      <!-- <input id="yawtext" type="text" value=0>
      <input type=range min=-1 max=1 step="0.05" value = 0 id='yawref'><br>
      <button id="flyup">Take-off</button> -->
      <button id="takeoff"font-family:"Times New Roman">Take-off</button>
      <button id="land"font-family:"Times New Roman">Land</button><br>
      <button id="CircleMovement"font-family:"Times New Roman">Circle-Movement</button>
      <input type=range min=-3.14 max=3.14 step="0.05" value = 0 font-family:"Times New Roman" id='curveAngle'><br>
      <button id="s-line"font-family:"Times New Roman">S-line</button>
      <input type=range min=-3.14 max=3.14 step="0.05" value = 0 id='SlineAngle'font-family:"Times New Roman"><br>
      <button id="8-loop"font-family:"Times New Roman">8-Loop</button>
      <input type=range min=-3.14 max=3.14 step="0.05" value = 0 id='8loopAngle'font-family:"Times New Roman"><br>
      <button id="direction"font-family:"Times New Roman">ShowDirection</button>
      <button id="plane"font-family:"Times New Roman">ShowPlane</button><br>
      <input type=range min=-5 max=-0.5 step="0.05" value = -2 id='CameraFar' font-family:"Times New Roman"> ChangeCamera<br>
    </div>  
    <div id="text"></div>
    <script src="build/three.min.js"></script>
    <script src="build/OrbitControls.js"></script>
    <script src="build/cannon.js"></script>

    <script src="tools/KeyboardState.js"></script>
    <script src="tools/Gyroscope.js"></script>
    <script src="tools/test2D.js"></script>
    <script src="tools/Linesegmentsgeometry.js"></script>
    <script src="tools/Linegeometry.js"></script>
    <script src="tools/Linematerial.js"></script>
    <script src="tools/Linesegments2.js"></script>
    <script src="tools/Line2.js"></script>
    <script src="tools/createFatLine.js"></script>
    <script src="tools/HudButton.js"></script>
    <script src="tools/jquery-2.1.4.min.js"></script>

    <script src="drone/qcommon.js"></script>
    <script src="drone/qangles.js"></script>
    <script src="drone/qservo.js"></script>
    <script>
      $('#curveAngle').change ( function() {
          angleRef1 = $(this).val();
          circleAngel = $(this).val();
      });
      $('#8loopAngle').change ( function() {
          angleRef2 = $(this).val();
          SloopAngle = $(this).val();
      });
      $('#SlineAngle').change ( function() {
          angleRef3 = $(this).val();
          SlineAngle = $(this).val();
      });
      $('#CameraFar').change ( function() {
          camera_far = $(this).val();
      });

      $('#takeoff').click(function() {
          takeoff = !takeoff;
      });
      $('#land').click(function() {
          land=!land;
      });

      $('#CircleMovement').click(function() {
          circleMove= !circleMove;
      });
      $('#s-line').click(function() {
          sline=!sline;
      });
      $('#8-loop').click(function() {
          sloop=!sloop;
      });
            
      $('#direction').click(function() {
          showdirection=!showdirection
      });
      $('#plane').click(function() {
          showplane=!showplane
      });

      var isVisible = true;
      var world, body; 
      var camera, upCamera, scene, renderer, keyboard, quadcopter, circle, camera_far = -2;
      var upCamera_renderer;
      var pickables = [];
      var omega, omega0, omega1, omega2, omega3;
      var omegaGain = 1.0, omegaHover;
      var spotLight;
      const SIZE = 1;
      const PROP_KK = 0.1;

      // flight maneuver
      // hovering
      var yref = 0;   
      var turning = true, rolling = true, pitching=true;
      var rYaw = 0, rRoll = 0, rPitch = 0;
      var yawAngle = 0, yawRef = 0;
      var rollAngle = 0, rollRef = 0;
      var pitchAngle = 0, pitchRef = 0;
      var circleMove = false, sline = false, sloop = false;
      var takeoff = false, land = false, showdirection = false, showplane = false;
      var targetPos;
      var clock = new THREE.Clock();
      var sceneHUD, cameraHUD;
      var HUD_object = {
        sprite: [],
        pointer: [],
        controlRange: [],
      }
      var box, line1, line3, line4, fatline = [];
      // HUD 的 PD 控制系統參數
      var y1, v1, speedRef = [], y2, v2, numberRef1, y3, v3, numberRef2, y4, v4, numberRef3, y5, v5, numberRef4;
      var angley1, anglev1, angleRef1, angley2, anglev2, angleRef2, angley3, anglev3, angleRef3;

      var cylindery1, cylindery2, cylindery3, cylindery4; 
      var showdetail = false;
      var mouse = new THREE.Vector2();
      var raycaster = new THREE.Raycaster();
      var SpeedChange=2;
      var circleAngel=0, SloopAngle=0, curveGeom1;

      var circle_curve, Sloopcurve, SlineCurve, point1, curveObjectt, geometryCurve, materialCurve;
      var handUp = 0, controlOne = 0, ControlPick1, mousepick = false;
      var nowPitch = false, nowHover = false, nowRoll = false, nowYaw = false;
      var ControlPick;


      var maxVelocity = 0.4;
      var curve_orientation = new THREE.Vector3();
      var orientationfull = new THREE.Vector3();
      var orientation = new THREE.Vector3();
      var Time1 = 0,Time2 = 0, Time3 = 0, dtt;
      var cylinder = [], ready = false, fly_toggle = false;
      var first = [true, true, true], firstlline2 = false, firstlline3 = false;

      init();
      animate();

      function init() {
        // =================================== Init ===================================
        keyboard = new KeyboardState();
        initThree();
        initCannon();
        createDashboard(HUD_object["sprite"], HUD_object["pointer"], HUD_object["controlRange"]);

        var gyro = new THREE.Gyroscope();
        scene.add (gyro)
        gyro.add (camera);

        quadcopter = new Quadcopter();
        spotLight.target = quadcopter.body;
        quadcopter.body.add (gyro);
        
        // =================================== HUD ===================================
        var upCamera_width = $('#Cameras').innerWidth();
        var upCamera_height = $('#Cameras').innerHeight();
        var upCamera_canvas = document.getElementById('mycanvas');
        upCamera_renderer = new THREE.WebGLRenderer({
          canvas: upCamera_canvas
        });
        upCamera_renderer.setSize(upCamera_width, upCamera_height);
        upCamera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

        // Camera
        cameraHUD = new THREE.OrthographicCamera(-20, 20, 10, -10, -10, 1000);


        // =================================== 陀螺儀設定 ===================================
        var _winDevice = !!navigator.platform.match(/Win32|Win16/);
        console.log(_winDevice + ' ' + navigator.platform);
        if(_winDevice){
            document.addEventListener('mousedown', hudButtonPick, false);
            document.addEventListener('mouseup', hudButtonUp, false);
            document.addEventListener('mousemove', hudButtonMove, false);
        }
        else {
            document.addEventListener('touchstart', hudButtonPickMobile, false);
            document.addEventListener('touchend', hudButtonUpMobile, false);
            document.addEventListener('touchmove', hudButtonMoveMobile, false);
        }

        // omegaHover: stable hover speed
        omegaHover = Math.sqrt ( body.mass * world.gravity.length()/4/PROP_KK );
        pickables.push( quadcopter.body.children[5],
                        quadcopter.body.children[6],
                        quadcopter.body.children[7],
                        quadcopter.body.children[8] );  
        console.log(pickables);
        targetPos = new THREE.Vector3(5, 5,-5);

        box = new THREE.Mesh( new THREE.CylinderGeometry(0.05,0.05, 0.1, 20), 
                              new THREE.MeshPhongMaterial({ visible: true }));
        scene.add(box);
        

        sy = [];
        sy[1]=v1=y2=v2=numberRef1=speedRef[1]=sy[2]=sv2=speedRef[2]=sy[3]=sv3=speedRef[3]=sy[4]=sv4=speedRef[4]=y3=v3=numberRef2=y4=v4=numberRef3=y5=v5=numberRef4=0;
        cylindery1=cylinderv1=cylinderRef1=cylindery2=cylinderv2=cylinderRef2=cylindery3=cylinderv3=cylinderRef3=cylindery4=cylinderv=cylinderRef4=0;
        angley1=anglev1=angleRef1=angley2=anglev2=angleRef2=angley3=anglev3=angleRef3=0;
        // document.addEventListener('mousedown', onDocumentMouseDown, false)

        // =================================== Fat Line ===================================
        fatline[0] = new FatLine(0);
        fatline[1] = new FatLine(1);

      }

      function onWindowResize() {
          // renderer resize
          renderer.setSize(window.innerWidth, window.innerHeight);
          whRatio = window.innerWidth / window.innerHeight;

          // perspective camera resize
          camera1.aspect = whRatio;
          camera1.updateProjectionMatrix();
          
          // orthographic camera resize
          halfH = 20;
          halfW = whRatio * halfH;
          cameraHUD.left = -halfW;
          cameraHUD.right = halfW;
          cameraHUD.top = halfH;
          cameraHUD.bottom = -halfH;
          cameraHUD.updateProjectionMatrix();

          dashBoard[0].position.set(-halfW / 2.5, -(halfH - halfW / 10), 0)
          dashBoard[1].position.set(-halfW / 8, -(halfH - halfW / 10), 0)
          dashBoard[2].position.set(halfW / 8, -(halfH - halfW / 10), 0)
          dashBoard[3].position.set(halfW / 2.5, -(halfH - halfW / 10), 0)
      }


      function onDocumentMouseDown(event) {
          mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
          mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          
          // find intersections
          raycaster.setFromCamera(mouse, camera);
          var intersects = raycaster.intersectObjects( pickables );
          if(intersects.length > 0){
            showdetail = !showdetail;
            console.log("2");
          }
      }


      function animate() {
          var dt = clock.getDelta();
          // console.log(dt)
          upCamera.position.copy(quadcopter.body.localToWorld(new THREE.Vector3(1, 1, camera_far)));
          upCamera.lookAt(quadcopter.body.position);
          upCamera_renderer.render(scene, upCamera);
        
          // 起飛
          if(takeoff) {
            if(!fly_toggle){
              yref = 5;
              fly_toggle = true;
              takeoff = false;
            }
          }
          
          // 降落
          if(land) {
            if(fly_toggle){
              yref = 0;
              fly_toggle = false;
              land = false;
            }
          }

          var f1 = speedServo(sy[1], v1, speedRef[1]); 
          dtt = 0.005;
          v1 += f1*dtt;
          sy[1] += v1*dtt;

          var f2 = numberServo(y2,v2,numberRef1); 
          v2 += f2*dtt;
          y2 += v2*dtt;
          cylindery1 =y2*0.05;
        
          var f3 = numberServo(y3,v3,numberRef2); 
          v3 += f3*dtt;
          y3 += v3*dtt;
          cylindery2 =y3*0.05;

          var f4 = numberServo(y4,v4,numberRef3); 
          v4 += f4*dtt;
          y4 += v4*dtt;
          cylindery3 =y4*0.05;

          var f5 = numberServo(y5,v5,numberRef4); 
          v5 += f5*dtt;
          y5 += v5*dtt;
          cylindery4 =y5*0.05;
          
          var f6= speedServo(sy[2],sv2,speedRef[2]); 
          sv2 += f6*dtt;
          sy[2] += sv2*dtt;
          
          var f7 = speedServo(sy[3],sv3,speedRef[3]); 
          sv3 += f7*dtt;
          sy[3] += sv3*dtt;
          
          var f8 = speedServo(sy[4],sv4,speedRef[4]); 
          sv4 += f8*dtt;
          sy[4]+= sv4*dtt;
        
          var f9 = speedServo(angley1,anglev1,angleRef1); 
          anglev1 += f9*dtt;
          angley1 += anglev1*dtt;

          var f10 = speedServo(angley2,anglev2,angleRef2); 
          anglev2 += f10*dtt;
          angley2 += anglev2*dtt;

          var f11 = speedServo(angley3,anglev3,angleRef3); 
          anglev3 += f11*dtt;
          angley3 += anglev3*dtt;


          // spherelight.position.set(body.position.x,body.position.y-0.1,body.position.z);
          //spherelight.position.y+=1;
          
          //console.log(dt);
          // orientation=targetPos.clone().sub(body.position);
      
        //  console.log(orientaionLocal);
          // console.log(body.position.y);
          if(body.position.y != 0) {
            box.visible = showdirection;
            console.log(showdirection)
            // 圓圈循線
            if(circleMove) {
              
              if(first[0]) {
                
                sline = false;
                sloop = false;
                show_plane[1].visible = false;
                show_plane[2].visible = false;
                fatline[1].line.visible = false;
                body.position.set(-RADIUS, 5, 0);
                
                
                first[0] = false;
              }
              CreateCurve(angley1);
              console.log(angley1)
              if(showplane)
                show_plane[0].visible = true;
              else
                show_plane[0].visible = false;

              scene.add(fatline[0].line);
              // circle_curve.rotation.z = angley1;
              fatline[0].line.rotation.z = angley1;
              show_plane[0].rotation.z = angley1;
              box.position.copy(circle_curve.getPointAt(Time1 % 1));
              box.position.y += 0.05

              targetPos = circle_curve.getPointAt(Time1 % 1);
              curve_orientation = targetPos.clone().sub(body.position).normalize();

              yref = targetPos.y;
              rYaw = 0;
              turning = false;  
              var localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
              var localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
              var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
              var x  = new THREE.Vector3(curve_orientation.clone().normalize().x,curve_orientation.clone().normalize().y,curve_orientation.clone().normalize().z);
              var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
              var zW = new THREE.Vector3 (0,0,1);
              var v = zW.projectOnPlane (yL);
              var yawAngle = rotateAlongAxisTo (x, yL, zL);

              if(yawAngle - 0.2 > 0) {
                rYaw = -omegaHover*0.1;
                turning = true;
              }
              if(yawAngle + 0.2 < 0){
                rYaw = omegaHover*0.1;
                turning = true;
              }

              targetPosx = new THREE.Vector3(0, targetPos.y, targetPos.z);
              orientationx = targetPosx.clone().sub(body.position).normalize();
              var z = zW.projectOnPlane(orientationx);
              pitchRef = 0;
              pitching = false;

              if(z.z > 0){
                pitchRef = 0.03;
                pitching = true;
              }
              if(z.z < 0){
                pitchRef = -0.03;
                pitching = true;
              }

              if(targetPos.x - body.position.x <= 0.5 && targetPos.x - body.position.x >= -0.5){ 
                  if(targetPos.z - body.position.z <= 0.5 && targetPos.z - body.position.z >= -0.5){
                      Time1 += 0.003;
                      turning = false;
                      pitchRef = 0;
                      pitching = false; 
                      rollRef = 0;
                      rolling = false;
                      ready = true;
                  }
              }  
            }
            else {
              first[0] = true;
            }

            if(sloop){
              if(!firstlline2){
                firstlline2=true;
                body.position.set(-2*RADIUS,5,0);
              }
              if(showplane)
                show_plane[1].visible=true;
              if(!showplane)
                show_plane[1].visible=false;

              CreateSCurve(angley2);
              scene.remove(fatline[0].line,show_plane[0],show_plane[2],fatline[1].line);
              //fatline[0].line.rotation.z=SloopAngle;
              show_plane[1].rotation.z=angley2;
              show_plane[0].visible=false;
              box.position.copy(Sloopcurve.getPointAt(Time2 % 1));
              box.position.y+=0.05
                //console.log(Time1);
              targetPos=Sloopcurve.getPointAt(Time2 % 1);
              curve_orientation=targetPos.clone().sub(body.position).normalize();
              // curve_orientation=circle_curve.getTangent(Time1 % 1);
              yref=targetPos.y;
              rYaw = 0;
              turning = false;  
              var localY, localZ;
              localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
              localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
              var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
              var x =new THREE.Vector3(curve_orientation.clone().normalize().x,curve_orientation.clone().normalize().y,curve_orientation.clone().normalize().z);
              var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
              var zW = new THREE.Vector3 (0,0,1);
              var v = zW.projectOnPlane (yL);
              var yawAngle =  rotateAlongAxisTo (x, yL, zL);
              if(yawAngle-0.2>0) {
                rYaw = -omegaHover*0.1;
                turning = true;
              }
              if(yawAngle+0.2<0){
                rYaw = omegaHover*0.1;
                turning = true;
              }
              targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
              orientationx=targetPosx.clone().sub(body.position).normalize();
              var z=zW.projectOnPlane(orientationx);
              pitchRef =0;
              pitching=false;  
              if(z.z>0){
                pitchRef = 0.025;
                pitching=true;
              }
              if(z.z<0){
                pitchRef = -0.025;
                pitching=true;
              }
              if(targetPos.x-body.position.x<=0.5&&targetPos.x-body.position.x>=-0.5){ 
                  if(targetPos.z-body.position.z<=0.5&&targetPos.z-body.position.z>=-0.5){
                      Time2 += 0.003;
                      turning=false;
                      pitchRef = 0;
                      pitching = false; 
                      rollRef = 0;
                      rolling = false;
                      ready=true;
                  }
              }  
            }
        
            if(sline){
                if(!firstlline3){
                  firstlline3=true;
                  body.position.set(-2*PI,5,0);
                }
                if(showplane)
                  show_plane[2].visible=true;
                if(!showplane)
                  show_plane[2].visible=false;
                CreateSline(angley3);
                scene.add(show_plane[2],fatline[1].line);
                scene.remove(fatline[0].line,show_plane[1],show_plane[0]);
                fatline[1].line.rotation.z=angley3;
                show_plane[2].rotation.z=angley3;
                box.position.copy(SlineCurve.getPointAt(Time3 % 1));
                box.position.y+=0.05
                //console.log(Time1);
                targetPos=SlineCurve.getPointAt(Time3 % 1);
                curve_orientation=targetPos.clone().sub(body.position).normalize();
                // curve_orientation=circle_curve.getTangent(Time1 % 1);
                yref=targetPos.y;
                rYaw = 0;
                turning = false;  
                var localY, localZ;
                localY = body.vectorToWorldFrame (new CANNON.Vec3(0,1,0) );
                localZ = body.vectorToWorldFrame (new CANNON.Vec3(0,0,1) );
                var yL = new THREE.Vector3 (localY.x, localY.y, localY.z);
                var x =new THREE.Vector3(curve_orientation.clone().normalize().x,curve_orientation.clone().normalize().y,curve_orientation.clone().normalize().z);
                var zL = new THREE.Vector3 (localZ.x, localZ.y, localZ.z);
                var zW = new THREE.Vector3 (0,0,1);
                var v = zW.projectOnPlane (yL);
                var yawAngle =  rotateAlongAxisTo (x, yL, zL);
                if(yawAngle-0.2>0) {
                  rYaw = -omegaHover*0.1;
                  turning = true;
                }
                if(yawAngle+0.2<0){
                  rYaw = omegaHover*0.1;
                  turning = true;
                }
                targetPosx=new THREE.Vector3(0,targetPos.y,targetPos.z);
                orientationx=targetPosx.clone().sub(body.position).normalize();
                var z=zW.projectOnPlane(orientationx);
                pitchRef =0;
                pitching=false;  
                if(z.z>0){
                  pitchRef = 0.025;
                  pitching=true;
                }
                if(z.z<0){
                  pitchRef = -0.025;
                  pitching=true;
                }
                if(targetPos.x-body.position.x<=0.5&&targetPos.x-body.position.x>=-0.5){ 
                    if(targetPos.z-body.position.z<=0.5&&targetPos.z-body.position.z>=-0.5){
                        Time3 += 0.003;
                        turning=false;
                        pitchRef = 0;
                        pitching = false; 
                        rollRef = 0;
                        rolling = false;
                        ready=true;
                    }
                }  
            }
        }

        //console.log(orientaion);
      
        /*if(controller&&yref==0)
        {
          yref=2;
              var turning = false;
          var rolling = false;
          var pitching= false;
        }
        if(controller)
        {
              var turning = false;
          var rolling = false;
          var pitching= false;
        }
        if(!controller&&yref>0.5)
        {
          yref=0.5;
        }
        if(!controller&&yref==0.5)
        {
          //omega0=omega1=omega2=omega3=0;
          var turning = true;
          var rolling = true;
          var pitching= true;
        }*/
        // not in thrust+/- mode, activate hoverServo
        if (omegaGain === 1.0) 
        omega = hoverServo(body, dt);
        else
        omega = omegaGain*omegaHover;  // this looks much better
        omega = Math.clamp (omega, 0, 50);
      // console.log("ryaw: "+rYaw+" "+turning);
        
        if (! turning) {
          //console.log("turningryaw: "+rYaw);
          rYaw = yawServo (body, dt);
          //console.log("servoryaw: "+rYaw);
          rYaw = Math.clamp (rYaw, -omega, omega);
        }  
      // always activate rollServo and pitchServo
        rRoll = rollServo (body, dt);
        rRoll = Math.clamp (rRoll, -omega*0.15, omega*0.15);
        rPitch = pitchServo (body, dt);
        rPitch = Math.clamp (rPitch, -omega*0.15, omega*0.15);
        
        var omega0Temp = omega0;
        var omega1Temp = omega1;
        var omega2Temp = omega2;
        var omega3Temp = omega3;
        omega0 = omega - rYaw - rRoll - rPitch;
        omega1 = omega + rYaw - rRoll + rPitch;
        omega2 = omega - rYaw + rRoll + rPitch;
        omega3 = omega + rYaw + rRoll - rPitch;//0x1742ab
        if(showdetail){
      
        cylinderRef1=omega0*8;
        cylinderRef2=omega1*8;
        cylinderRef3=omega2*8;
        cylinderRef4=omega3*8;
        // quadcopter.body.children[13].children[0].visible=true;
        // quadcopter.body.children[14].children[0].visible=true;
        // quadcopter.body.children[15].children[0].visible=true;
        // quadcopter.body.children[16].children[0].visible=true;
        // quadcopter.body.children[25].children[0].visible=true;
        // quadcopter.body.children[26].children[0].visible=true;
        // quadcopter.body.children[27].children[0].visible=true;
        // quadcopter.body.children[28].children[0].visible=true;
      
        quadcopter.body.children[25].children[0].scale.y = -5*cylindery1;
        quadcopter.body.children[26].children[0].scale.y = 5*cylindery2;
        quadcopter.body.children[27].children[0].scale.y = -5*cylindery3;
        quadcopter.body.children[28].children[0].scale.y = 5*cylindery4;
      /* quadcopter.body.children[13].add(new THREE.AxesHelper (0.5));
      quadcopter.body.children[14].add(new THREE.AxesHelper (0.5));
      quadcopter.body.children[15].add(new THREE.AxesHelper (0.5));
      quadcopter.body.children[16].add(new THREE.AxesHelper (0.5));*/
      }
      else {
        // quadcopter.body.children[13].children[0].visible=false;
        // quadcopter.body.children[14].children[0].visible=false;
        // quadcopter.body.children[15].children[0].visible=false;
        // quadcopter.body.children[16].children[0].visible=false;
        // quadcopter.body.children[25].children[0].visible=false;
        // quadcopter.body.children[26].children[0].visible=false;
        // quadcopter.body.children[27].children[0].visible=false;
        // quadcopter.body.children[28].children[0].visible=false;
      /*  quadcopter.body.children[13].remove(new THREE.AxesHelper (0.5));
      quadcopter.body.children[14].remove(new THREE.AxesHelper (0.5));
      quadcopter.body.children[15].remove(new THREE.AxesHelper (0.5));
      quadcopter.body.children[16].remove(new THREE.AxesHelper (0.5));*/
      }
        /*omega0 = omega  - rRoll - rPitch;
        omega1 = omega  - rRoll + rPitch;
        omega2 = omega  + rRoll + rPitch;
        omega3 = omega  + rRoll - rPitch;*/
        /*omega0 = omega - rYaw;
        omega1 = omega + rYaw;
        omega2 = omega - rYaw;
        omega3 = omega + rYaw;*/
        body.torque = new CANNON.Vec3(0,0,0);
        body.angularDamping = 0.39
        body.linearDamping = 0.39
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega0*omega0,0), new CANNON.Vec3(-1.0*SIZE, 0, SIZE) )
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega1*omega1,0), new CANNON.Vec3(-1.0*SIZE, 0, -SIZE) )
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega2*omega2,0), new CANNON.Vec3( 1.0*SIZE, 0, -SIZE) )
        body.applyLocalForce (new CANNON.Vec3(0,PROP_KK*omega3*omega3,0), new CANNON.Vec3( 1.0*SIZE, 0, SIZE) ) 
          
        let KT = 0.1;
        // need to add the last argument
        body.torque.vadd (new CANNON.Vec3(0, -KT*omega0*omega0,0), body.torque);
        body.torque.vadd (new CANNON.Vec3(0,  KT*omega1*omega1,0), body.torque);
        body.torque.vadd (new CANNON.Vec3(0, -KT*omega2*omega2,0), body.torque);
        body.torque.vadd (new CANNON.Vec3(0,  KT*omega3*omega3,0), body.torque);
        //bug ... for pitching, weird number from KT not zero
        //console.log (body.torque)         
        //console.log("omega0:"+omega0.toFixed(2)+" omega1:"+omega1.toFixed(2)+" omega2:"+omega2.toFixed(2)+" omega3:"+omega3.toFixed(2));
        //requestAnimationFrame( animate );
        //renderer.render( scene, camera );
          var angle = [], t = 10;
          for(i=0;i<4;i++){
          angle[i] = 0
          }
          angle[0] = 4.9 / 14 * omega0;
          numberRef1=-omega0.toFixed(1);
          HUD_object["sprite"][0].text = y2.toFixed(2);
          angle[1] = 4.9 / 14 * omega1;
          numberRef2=omega1.toFixed(1);
          HUD_object["sprite"][1].text =y3.toFixed(2);
          numberRef3=-omega2.toFixed(1);
          angle[2] = 4.9 / 14 * omega2;
          HUD_object["sprite"][2].text = y4.toFixed(2);
          numberRef4=omega3.toFixed(1);;
          angle[3] = 4.9 / 14 * omega3;
          HUD_object["sprite"][3].text = y5.toFixed(2);
          for (i = 0; i < 4; i++) {
          angle[i] = Math.clamp(angle[i], 0, 4.9);
          speedRef[i+1]= -angle[i] + 0.86
          HUD_object["pointer"][i].rotation.z = sy[i+1];
          }
          render();
          handleKeys();
          HUDControler();
        updatePhysics();
        // render propeller in quadcopter.body
      // console.log(quadcopter.body.children[25].children[0].mesh.parameters)
        quadcopter.body.children[25].rotation.z += 2.5*omega0*dt;//motor1
        quadcopter.body.children[26].rotation.z -= 2.5*omega1*dt;//motor2
        quadcopter.body.children[27].rotation.z += 2.5*omega2*dt;//motor3
        quadcopter.body.children[28].rotation.z -= 2.5*omega3*dt;//motor4
      }
      function render(){
        camera.lookAt(quadcopter.body.position);
        renderer.clear(true);
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        renderer.render(sceneHUD, cameraHUD);
      }
      function handleKeys () {
        keyboard.update();
        // console.log("keyborad:",keyboard.down)
        const RATIO = 1.0003;
        /////////////////////////////////////////////////////////////
        // for hovering
        if (keyboard.pressed('up')) {
          // controller=true;
          $('#thrustUp').css ("background-color",  'red');
          omegaGain *= RATIO;
        }
        if (keyboard.up('up')) {
          yref = body.position.y;
          console.log ('set yref: ' + yref);
          omegaGain = 1;
          $('#thrustUp').css ("background-color",  'white');
        }
        if (keyboard.pressed('down')) {
          $('#thrustDo').css ("background-color",  'yellow');
          omegaGain /= RATIO;
        }
        if (keyboard.up('down')) {
          yref = body.position.y;
          console.log ('set yref: ' + yref);
          $('#thrustDo').css ("background-color",  'white');
          omegaGain = 1;
        }
        /////////////////////////////////////////////////////////////
        // for rolling
        if (keyboard.pressed('D')) {
          $('#rollRight').css ("background-color",  'yellow');
              //rRoll = omegaHover*0.01;
              //rolling = true;
          rollRef = 0.1;
        }
        if (keyboard.up('D')) {
          $('#rollRight').css ("background-color",  'white');
          //rRoll = 0;//-omegaHover*0.005;
          rollRef = 0;
          rolling = false;  
        }
        if (keyboard.pressed('A')) {
          $('#rollLeft').css ("background-color",  'yellow');
              //rRoll = - omegaHover*0.01;
              //rolling = true;
              rollRef = -0.1;
        }
        if (keyboard.up('A')) {
          $('#rollLeft').css ("background-color",  'white');
          rollRef = 0;
          rolling = false;    
        }
        /////////////////////////////////////////////////////////////
        // for pitching
        if (keyboard.pressed('W')) {
          $('#pitchFore').css ("background-color",  'yellow');
              //rRoll = omegaHover*0.01;
              //rolling = true;
          pitchRef = 0.1;
          pitching=true;
        }
        if (keyboard.up('W')) {
          $('#pitchFore').css ("background-color",  'white');
          //rRoll = 0;//-omegaHover*0.005;
          pitchRef = 0;
          pitching = false; 
        }
        if (keyboard.pressed('S')) {
          $('#pitchAft').css ("background-color",  'yellow');
              //rRoll = - omegaHover*0.01;
              //rolling = true;
              pitchRef = -0.1;
              pitching=true;
        }
        if (keyboard.up('S')) {
          $('#pitchAft').css ("background-color",  'white');
          pitchRef = 0;
          pitching = false;   
        }
        /////////////////////////////////////////////////////////////
        // for yawing
          if (keyboard.pressed('left')) {
          $('#cwTurn').css ("background-color",  'yellow');
              rYaw = omegaHover*0.1;
              turning = true;
        }
        if (keyboard.up('left')) {
          $('#cwTurn').css ("background-color",  'white');
              rYaw = 0;
              turning = false;
          
            // set up stopping reference
            yawRef = getBodyYaw(body);
          if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
            console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
            //pidR2.setRef (Math.cos(yawRef), Math.sin(yawRef));            
        }
        if (keyboard.pressed('right')) {
          $('#ccwTurn').css ("background-color",  'yellow');
              rYaw = -omegaHover*0.1;
              turning = true;
        }
        if (keyboard.up('right')) {
          $('#ccwTurn').css ("background-color",  'white');
          rYaw = 0;
          turning = false;
          // set up stopping reference
          yawRef = getBodyYaw(body);
          if((yawRef/Math.PI*180).toFixed(2)==360)yawRef=0;
              //if((yawRef/Math.PI*180).toFixed(2)>0&&(yawRef/Math.PI*180).toFixed(2)<1)yawRef=0;
            console.log ('set thetaRef: ' + (yawRef/Math.PI*180).toFixed(2));
            console.log(turning+omegaHover);
        }
        if (keyboard.pressed('space')) {
          yawRef = getBodyYaw(body);
          rYaw=0;
          turning=false;
          pitchRef = 0;
          pitching = false; 
          rollRef = 0;
          rolling = false;  
          $('#stop').css ("background-color",  'yellow');
        }
        if (keyboard.up('space')) {
          $('#stop').css ("background-color",  'white');
        }
          $('#gain').val (omegaGain);
        $('#yreftext').val (yref.toFixed(2));
      }
      function updatePhysics() {
        var timeStep=1/48;
        world.step(timeStep);
        // Copy coordinates from Cannon.js to Three.js
        quadcopter.body.position.copy(body.position);
        quadcopter.body.quaternion.copy(body.quaternion); 
        yawAngle = getBodyYaw(body);
      if((yawAngle/Math.PI*180).toFixed(2)==360)yawAngle=0;
        rollAngle = getBodyRoll(body);
        pitchAngle = getBodyPitch(body);
        
      /* $('#text').html (`${omegaGain.toFixed(3)}:[ ${body.position.x.toFixed(3)}, ${body.position.y.toFixed(2)}, 
          ${body.position.z.toFixed(3)} ] <br>      
        [${yawRef.toFixed(3)}] : [Y: ${yawAngle.toFixed(3)} ] [R: ${rollAngle.toFixed(3)} ] [P: ${pitchAngle.toFixed(3)} ]  
        <br>
          [omega0:${omega0.toFixed(3)}] : [omega1: ${omega1.toFixed(3)} ] [omega2: ${omega2.toFixed(3)} ] [omega3: ${omega3.toFixed(3)} ]         `);  */
      }

    </script>
  </body>
</html>